## Code Reuse: Functions and Modules





a Chunk of Code

```py
vowels = set('aeiou')
word = input("Provide a word")
found = vowels.intersection(set(word))
for vowel in found:
    print(vowel)
    
# into function
def search4vowel():
    vowels = set('aeiou')
    word = input("Provide a word")
    found = vowels.intersection(set(word))
    for vowel in found:
        print(vowel)

search4vowel()   
```



#### Functions

Functions are fundamental building `blocks of reusable code`. They allow we to encapsulate a task or a set of instructions into a self-contained block, which can be executed whenever needed.



**1. Defining a Function and Call**

A function is defined using the `def keyword`, followed by a `function name`, `parentheses (`), and a `colon :`. The **indented block of code** following the `: `is the body of the function.

```PY
def greet_user():
    print("Hello!")

# Calling a Function, neither arguments nor returns
greet_user()
```

**2. Function with Arguments:** 

Passing Information to a Function

```PY
def greet_user(username):
    print(f"Hello, {username.title()}!")
    
greet_user('Alice')
```

**3. Return Values**

Functions Return a Results

```py
def search4vowel(word):
    vowels = set('aeiou')
    found = vowels.intersection(set(word))
    return bool(found)

search4vowel('hitch-hiker') 
search4vowel('sky')
```



-----

###### Arguments and Parameters

We defined greet_user() to require a value for the variable username. Once we called the function and gave it the information (a person’s name), it printed the right greeting.

- An `argument` is a piece of information that’s passed from a function call to a function, while the value was assigned to the `parameter` username

###### One Argument

```py
def greet_user(username):
    print(f"Hello, {username.title()}!")
    
greet_user('Alice')
```



###### Multiple Parameters

A function call may need multiple arguments. We can use `positional arguments`, which need to be in **the same order** `the parameters` were written. In other words, the number of arguments in the call **must match exactly with** the function definition.



```PY
# Positional Arguments
def describe_pet(animal_type, pet_name):
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")
    
describe_pet('hamster', 'harry')

def multiply(a, b):
    return a * b

result = multiply(5, 4) # Positional arguments
print(result) # Outputs: 6
```

###### Keyword Arguments

A keyword argument is a **name-value pair** that we pass to a function. We **directly associate** the name and the value within the argument, so when you pass the argument to the function. In other words, pass arguments by explicitly specifying the name of the parameter.

```PY
# Keyword Arguments
def describe_pet(animal_type, pet_name):
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")
    
describe_pet(animal_type='hamster', pet_name='harry')   


def add_numbers(num1, num2):
    return num1 + b

result = add_numbers(num1 = 5, num2 = 10)
```

###### Default Values

We can define a `default value` for each parameter. If an argument for a parameter is provided in the function call, Python uses the argument value. If not, it uses the parameter’s default value.

```PY
def describe_pet(pet_name, animal_type='dog'):
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet(pet_name='willie')

####
def add_numbers(num1 = 5, num2):
    return num1 + num2

result = add_numbers(num2 = 10)
print(result)
```

###### Passing a List

```PY
def greet(names):
    for name in names:
        msg = f"Hello, {name.title()}!"
        print(msg)
        
usernames = ['hannah', 'ty', 'margot']
greet(usernames)
```



###### Return Values

A function can process some data and then return a value or set of values. The value the function returns is called a return value. 

###### Returning One Value

We need to provide a variable that the return value can be assigned to.

```PY
def get_formatted_name(first_name, last_name):
    full_name = f"{first_name} {last_name}"
    return full_name.title()

musician = get_formatted_name('jimi', 'hendrix')
print(musician)

####
def add_numbers(num1 = 5, num2):
    return num1 + num2

result = add_numbers(num2 = 10)
print(result)
```

###### Returning More Than One Value:

```PY
def operations(a, b):
    return a + b, a - b

sum, difference = operations(10, 5)
print(sum, difference) # Outputs: 15 5
```

###### Returning a Dictionary

A function can return any kind of value you need it to, including more complicated data structures like lists and dictionaries.

```PY
def build_person(first_name, last_name):
    person = {'first': first_name, 'last': last_name}
    return person

musician = build_person('jimi', 'hendrix')
print(musician)
```



##### Passing an Arbitrary Number of Arguments

###### asterisk

Sometimes we won’t know ahead of time how many arguments a function needs to accept. The function in the following example has one parameter, *toppings, but this parameter collects as many arguments. The **asterisk in the parameter** name *toppings tells Python to make a **tuple** called toppings, containing all the values this function receives.

```PY
def make_pizza(*toppings):
    print(toppings)

make_pizza('pepperoni')
make_pizza('mushrooms', 'green peppers', 'extra cheese')

##
def make_color(*fa):
    print(fa)

make_color('red')
make_color('red', 'green', 'blue')
```

###### Using Arbitrary Keyword Arguments

The **double asterisks** before the parameter tell Python to create a **dictionary** called kwargs containing all the extra name-value pairs the function receives.

```PY
def build_profile(first, last, **user_info):
    user_info['first_name'] = first
    user_info['last_name'] = last
    return user_info

user_profile = build_profile('albert', 
                             'einstein', 
                             location='princeton',
                             field='physics')
print(user_profile)

##
def print_values(**kwargs):
    for key in kwargs:
        print(f"{key}: {kwargs[key]}")

print_values(name="Alice", job="Engineer")
```

```py
def profile(first, last, **user_info):
    user_info['first_name'] = first
    user_info['last_name'] = last
    return user_info

user_profile = profile('albert', 
                       'einstein', 
                        location='princeton',
                        field='physics')
print(user_profile)

def values(*args, **kwargs):
    for arg in args:
        print(arg)
    for key in kwargs:
        print(f"{key}: {kwargs[key]}")

values(11, 22, 33, name="Porter", job="Finance")
```

###### **Lambda/ Anonymous**

A lambda function can take n number of arguments **at a time**. But it returns only one argument at a time. They don't have a name. 

```PY
# lambda argument: code, parameters
lambda x, y: x + y, (2, 3)
```

相當於

```PY
def fun(x, y):
    return x+y

fun(2,3)
```

唯一不同是上述lambda用法該行執行完後此函數就消失了，無法再呼叫使用。


```python
# lambda function `without` parameters ：
f = lambda: "Hello, Puli!"
print(f())  # output: Hello, Puli!
```


```python
# lambda `with one` parameter a：
x = lambda a : a + 100
print(x(5))
```


```python
# lambda `with multi parameters` a 與 b：
x = lambda a, b : a * b
print(x(20, 6))
```

**Combine labda function with map()、filter() 和 reduce()** 

A method from lambda and a list are passed to `map() function`. The function is executed for all of the elements within the list


```python
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))
print(squared)  #  [1, 4, 9, 16, 25]
```

The `filter() method` accepts two arguments: a function from lambda and a list. The result show those elements that `returned True` when supplied to the function


```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4, 6, 8]
```

with List Comprehension + a Function from lambda

```py
# calculate square of each number of lists using list comprehension    
squares = [lambda num = num: num ** 2 for num in range(0, 11)]       
for square in squares:    
       print('The square value of all numbers from 0 to 10:',square(), end = " ")  
# output: [0 1 4 9 16 25 36 49 64 81 100]       
```

with if-else + a Function from lambda

```py
# use lambda function with if-else    
Minimum = lambda x, y : x if (x < y) else y       
print('The greater number is:', Minimum( 35, 74 )) # [35]
```

###### Reduce() and lambda functions

You’re getting very good at using lambda functions! Here’s one more function to add to your repertoire of skills. The `reduce()` function is useful for performing some computation on a list and, unlike `map()` and `filter()`, returns a single value as a result. To use `reduce()`, you must import it from the `functools` module. Remember `gibberish()` from a few exercises back?

```py
# Define gibberish
def gibberish(*args):
    """Concatenate strings in *args together."""
    hodgepodge = ''
    for word in args:
        hodgepodge += word
    return hodgepodge
```





----

## Modules and Packages

Modules and packages are key concepts that facilitate code **reuse and organization**. 

One advantage of functions is the way they separate blocks of reused code from your main program.  We can go a step further by storing many functions in a `separate file` called a **module** and then importing that module into your main program. 



**1. Importing an Entire Module**

A module is a file ending in `.py` that contains the code you want to import into your program. 

```py
import math
print(math.sqrt(16)) # Outputs: 4.0
```

To make this module, we’ll remove everything from the file `pizza.py` except the function make_pizza():

```PY
# pizza.py
def make_pizza(size, *toppings):
    print(f"\nMaking a {size}-inch pizza with the following toppings:")
    for topping in toppings:
        print(f"- {topping}")
```

```PY
# main.py
import pizza

pizza.make_pizza(16, 'pepperoni')
pizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
```

When Python reads this file, the line `import pizza` tells Python to open the file `pizza.py` in the same folder and copy all the functions from it into this program.



###### 2. Importing Specific Functions

Certain objects of a module are needed 

```PY
from pizza import make_pizza

make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
```

###### Using as to Give a Function an Alias

An alternate name similar to a `nickname` for the function.

```PY
from pizza import make_pizza as mp

mp(16, 'pepperoni')
mp(12, 'mushrooms', 'green peppers', 'extra cheese')
```

###### Using as to Give a Module an Alias

```PY
import pizza as p

p.make_pizza(16, 'pepperoni')
p.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
```



#### Packages

A package is a hierarchical file directory structure that defines a single Python application environment consisting of many modules and subpackages.

**Basic Package Structure:** A package is typically a directory with Python files and a file named __init__.py. The `__init__.py` file can be empty but is required to treat the directory as a Python package.

> mypackage/
>
> ├── __init__.py
>
> ├── submodule1.py
>
> └── submodule2.py

**Using Packages:**

```PY
from mypackage import submodule1
submodule1.my_function()
```

**Creating wer Own Package:**

- Create a directory for the package with a name that represents wer package.
- Add Python files and an __init__.py file.



###### Python's Standard Library 

Python's standard library is a vast collection of modules that provide a wide range of functionalities, from mathematical operations to handling internet protocols.

**Modules math:**

```PY
import math
print(math.factorial(5)) # Outputs: 120
print(math.pow(2, 3)) # Outputs: 8.0
```

**datetime:**

```PY
from datetime import datetime
now = datetime.now()
print(now.strftime("%Y-%m-%d %H:%M:%S")) # Outputs formatted current time
```

**os:** Operating System Interface

```PY
import os
print(os.getcwd()) # Outputs current working directory
```

**sys:** System-Specific Parameters and Functions

```PY
import sys
print(sys.path) # Outputs the list of search paths for modules
```

**json:** JSON Encoder and Decoder The json module is used for parsing JSON into a Python dictionary and converting Python objects back to JSON

```PY
import json
json_data = '{"name": "Alice", "age": 30}'
python_obj = json.loads(json_data)
print(python_obj) # Outputs: {'name': 'Alice', 'age': 30}
```

**random:**

```PY
import random
print(random.randint(1, 10)) # Outputs a random integer between 1 and 10
```

**requests:** HTTP Requests

```PY
import requests
response = requests.get('https://api.github.com')
print(response.status_code) # Outputs the status code of the response
```



----

#### lambda（匿名函數）

lambda 函數是一種小型、匿名的、內聯函數，它可以具有任意數量的參數，但只能有一個運算式。匿名函數不需要使用 def 關鍵字定義完整函數。lambda 函數通常用於編寫簡單的、單行的函數，通常在需要函數作為參數傳遞的情況下使用，例如在 map()、filter()、reduce() 等函數中。

lambda 函數特點：

- lambda 函數是匿名的，它們沒有函數名稱，只能通過賦值給變數或作為參數傳遞給其他函數來使用。
- lambda 函數通常只包含一行代碼，這使得它們適用於編寫簡單的函數。

lambda 語法格式：

```PY
lambda arguments: expression
```

- lambda是 Python 的關鍵字，用於定義 lambda 函數。

- arguments 是參數列表，可以包含零個或多個參數，但必須在冒號(:)前指定。

- expression 是一個運算式，用於計算並返回函數的結果。

  

  

- `gibberish()` simply takes a list of strings as an argument and returns, as a single-value result, the concatenation of all of these strings. In this exercise, you will replicate this functionality by using `reduce()` and a lambda function that concatenates strings together.

- Import the `reduce` function from the `functools` module.
- In the `reduce()` call, pass a lambda function that takes two string arguments `item1` and `item2` and concatenates them; also pass the list of strings, `stark`. Assign the result to `result`. The first argument to `reduce()` should be the lambda function and the second argument is the list `stark`.

```py
# Import reduce from functools
from functools import reduce

# Create a list of strings: stark
stark = ['robb', 'sansa', 'arya', 'brandon', 'rickon']

# Use reduce() to apply a lambda function over stark: result
result = reduce(lambda item1, item2: item1 + item2, stark)

# Print the result
print(result)
```



## 

###### Creating Own Modules:

Suppose we create a file named `module.py` with the following content

```PY
# module.py
def greeting(name):
    return print(f"Hello, {name}!")

number = 5
```

###### Using Own Module: 

If the script is in `the same directory` as `mymodule.py`

```PY
# main.py
import mymodule

print(mymodule.greeting("Alice")) # Outputs: Hello, Alice!
print(mymodule.number) # Outputs: 5
```

